---
title: Kotlin Summary
tags: [Kotlin]
---

### 1. Before all

#### What's Kotlin

1. By Jetbrains which created Intellij IDEA
2. Targeting JVM and more, interoperate with Java
3. Concise and safe, with many modern features

#### the REPL(read, evaluate, print, loop)

Install Kotlin commandline tools in macOS:

```bash
brew install kotlin
```

Execute `kotlinc` to start REPL

![](http://tao93.top/images/2019/11/05/1572994981.png)

### 2. Types

#### Built-in types

`String, Char, Boolean, Int, Double, List<T>, Set<T>, Map<K, V>, Array<T>`

Not like Java, Kotlin has no primitives (int, float etc.) hence avoids the boxing between primitives and objects. 

However, in byte code generated by Kotlin, primitives are used to improve performance.

### 3. Conditionals

#### Conditional operators

Operator | Description
:-: | :-:
< | Evaluates whether the value on the left is less than the value on the right.
<= | Evaluates whether the value on the left is less than or equal to the value on the right.
> | Evaluates whether the value on the left is greater than the value on the right.
>= | Evaluates whether the value on the left is greater than or equal to the value on the right.
== | Evaluates whether the value on the left is equal to the value on the right (like equals in Java).
!= | Evaluates whether the value on the left is not equal to the value on the right.
=== | Evaluates whether the two instances point to the same reference (like == in Java).
!== | Evaluates whether the two instances do not point to the same reference.

### 4. Functions

#### Kotlin supports file level functions

```kotlin
fun main() {
    println(fileLevelFunc())
}

fun fileLevelFunc() = "file level" // expression function
```

#### Default value of parameters

```kotlin
fun main() {
    greeting("Earth") // default value for 2nd parameter
}

fun greeting(name: String, greeting: String = "good morning") {
    println("${greeting.capitalize()}! $name.") // e.g. Good morning! Saturn.
}
```

#### Named function parameters

```kotlin
fun main() {
    greeting(greeting = "Hello", name = "Earth") // named parameters
}

fun greeting(name: String, greeting: String = "good morning") {
    println("${greeting.capitalize()}! $name.") // e.g. Good morning! Saturn.
}
```

#### Function names in backticks

It's said this is useful to call Java methods whose names are reserved words in Kotlin, or to name some special methods.

```kotlin
fun `ðŸ˜‚`() { }

fun main() {
    `ðŸ˜‚`() // call a function
}
```

#### Inline functions

Kotlin support inline functions, which is good for performance.

```kotlin
inline fun factorial(n: Int): Int {
    return if (n > 2) {
        n * factorial(n - 1)  // wrong, recursion is not allowed for inline functions
    } else {
        n
    }
}
```

### 5. Anonymous functions

An example of anoymous function:

```kotlin
val numLetters = "Mississippi".count({ letter ->
    letter == 's'
})
print(numLetters) // would Prints 4
```
The complete structure of an anoymous function should be like:

```kotlin
val funcVariable: (ParamType1, ParamType2) -> ReturnType = 
{ param1: ParamType1, param2: ParamType2 ->
	...
	expression_to_be_returned // no return keyword, just put the expression here
}
```
Parameter types are usually omitted when they caould be inferred. Single parameter's name could be omitted if its type could ba inferred, and we take `it` as the parameter name. Unused parameter name could be marked as **`_`**.

Examples:

```kotlin
val numLetters = "Mississippi".count({
    it == 's'
})

val afterFilter = "Mississippi".filterIndexed({ _, char->
    char != 's'
})
print(afterFilter) // prints Miiippi
```

***Note***: an anonymous function must be called immediately, assigned to a variable, or be passed as a parameter.

Anonymous functions as parameter is often in a different style when it is required as the **last** parameter in another function:

```kotlin
// count starting from a specified index.
fun count(str: String, startIdx: Int, predicate: (Char) -> Boolean): Int {
    return str.substring(startIdx).count(predicate)
}

// style 1
count("Mississippi", 5, {
    it == 's'
})

// style 2, looks like definition of count, but actually it's anonymous function as parameter
count("Mississippi", 5) {
    it == 's'
}
```

Want to declare a function type that returns something like `void` in Java? You need the `Unit`.

You can also refer a non anonymous function as parameter in call to another function by using `::`. But I don't think this is common.

```kotlin
fun isS(char: Char): Boolean {
    return char == 's'
}
    
val numLetters = "Mississippi".count(::isS)
```

### 6. Null Safety and Exceptions

For nullable variables, there are some common solutions to handle potential null pointer exceptions.

**Safe call operator**:

```kotlin
var beverage = readLine()?.capitalize() // the type of beverage would be String?.
```

**Nonnull assertion**:

```kotlin
var beverage = readLine()!!.capitalize() // your responsibility to avoid null pointer exception
```

**Check before use**:

```kotlin
val result = readLine()
var beverage = if (result != null) { // type of beverage would be String.
    result.capitalize() + result.toLowerCase()
} else {
    ""
}
```

However, check before use isn't always safe, e.g. a field of an object might be assigned null between your null checking and usage of the field. For such case, you would need a local variable to get rid of this risk:

```kotlin
val localVar = a.b
if (localVar != null) {
    // do something refers a.b
} else {
    ...
}
```

**Elvis operator**:

```kotlin
var beverage = readLine()?.capitalize() ?: ""  // type of beverage would be String.
```

#### Exceptions in Kotlin

Kotlin doesn't require handling of those checked Exceptions of Java. Therefore you can do IO operations without try-catch and exception declaration in the method signature.

### 7. Collections

#### destructuring

```kotlin
val (type, name, price) = aList  // fetch the leading 3 elements from a list.

val (type, _, price) = aList // skip elements in specified indexes.
```

#### protection of immutable list is not valid at runtime

```kotlin
val a = listOf(1, 2, 3)
(a as MutableList<Int>).set(0, 100)
println(a) // would print [100, 2, 3]
```

### 8. Class definition

#### Visibility modifiers of class members

Modifier | Description
:-: | :-:
public (default) |	The function or property will be accessible by code outside of the class. By default, functions and properties without a visibility modifier are public.
private | The function or property will be accessible only within the same class.
protected | The function or property will be accessible only within the same class or its subclass.
internal | The function or property will be accessible within the same module.

#### Class fields

For class fields, default `getter` is available for `val` and `var` fields. But `setter` is only for `var` fields. Yet we can override the default `setter` and `getter`:

```kotlin
class X(_name: String, _age: Int) {
    
    // a field always return capitalized string when you get it
    val name = _name
        get() = field.capitalize()
    
    // a field only allows increasing
    var age = _age
        set(value) {
            if (value > field) {
                field = value
            }
        }
}
```

You can override the visibility of a setter to make it less permissive then field's visibility. E.g., you want to make a field readable everywhere but only writable in the file:

```kotlin
class X(_age: Int) {
    // a field only allows increasing in current file.
    var age = _age
        private set(value) {
            if (value > field) {
                field = value
            }
        }
}
```

#### Computed fields

Has getter or/and setter but no real fields to store values.

```kotlin
class Dice() {
    val rolledValue
        get() = (1..6).shuffled().first()
}
```

### 9. Object initialization

#### The primary contructor

Add parameter list inside a pair of parenthesis after the class name, make it looks like a method. For fields **with default getter and setter**, you can declare them inside the parameter list by adding `var` or `val`:

```kotlin
// visibility modifier and default values are also available
class X(val name: String, private var age: Int = 0)
```

#### secondary constructor

Must call the primary constructor or another secondary constructor(of course no cycle call)

```kotlin
class X(val name: String, private var age: Int = 0) {
    constructor(): this("Unknown")  // call primary constructor with default parameter
}
```

Apart from default parameter values, named parameters are also available for constructors.

#### Lazy initialization

Only initialize a field when it's accessed (by the getter)

```kotlin
class X {
    val number: Int by lazy {
        (0 until 10).shuffled().first()
    }
}
```

### 10. Inheritance

In Java, we only override methods. But in Kotlin, both class functions and fields could be overridden. Also, in Kotlin, classes, functions and fields must be marked `open` explicity to make them inheritable or able to be overridden. 

```kotlin
open class Room(val name: String) {
    protected open val dangerLevel = 5

    fun description() = "Room: $name\n" +
            "Danger level: $dangerLevel"

    open fun load() = "Nothing much to see here..."
}

class TownSquare : Room("Town Square") {
    override val dangerLevel = super.dangerLevel - 3

    final override fun load() = "The villagers rally and cheer as you enter!"
}
```

Functions are final by default unless they are inherited from an open class. To prevent inherited functions from being overriden again, we can mark it `final`.

In Kotlin's inheritance, we always have:

![](http://tao93.top/images/2019/11/05/1572968935.png)

However, when compiled into bytecode, the class Room doesn't inherits the class Any in JVM rule.

### 11. Objects

#### singleton by `object` keyword

```kotlin
fun main() {
    UserManager.getUser(2)
}

// constructors are not allowed for such objects
object UserManager {
    private val users = mutableListOf<String>("A", "B")
    
    fun getUser(idx: Int): String? {
        return users.getOrNull(idx)
    }
}
```

#### Anonymous inner class 

In java, we often implement interfaces or extend simple classes as anonymous inner class, such as click listeners and view adapters.

In Kotlin, they could be divided into 2 categories. For interfaces with only one method and declared in Java, we can use a format called Lambda:

```kotlin
generateButton.setOnClickListener { view ->
    fetchData()
}

fun useI(i: I) {

}

useI(I {
    // ...
})
```

```java
// I.java
public interface I {
    void f();
}
```

For other cases, the format is like this:

```kotlin
listView.adapter = object : BaseAdapter() {  // call the constructor here.
    override fun getView(pos: Int, view: View?, parent: ViewGroup?): View {
        // ...
    }

    override fun getItem(pos: Int): Any {
        // ...
    }

    override fun getItemId(pos: Int): Long {
        // ...
    }

    override fun getCount(): Int {
        // ...
    }
}
```

Nested classes by default cannot access members of the outer class, unless they are marked inner:

```kotlin
class Outer {
    fun outerFunc() = "1"

    class Nested {
        init {
            outerFunc()  // wrong, unable to access
        }
    }

    inner class Inner {
        init {
            outerFunc()  // ok
        }
    }
}

object UserManager {
    private val users = mutableListOf<String>("A", "B")

    class User {
        init {
            users // ok. this is nested class inside an object class.
        }
    }
}
```

#### Data classes

Data classes are suitable for model, that's what the `data` means.

```kotlin
data class Coordinate(var x: Int, var y: Int) {
    val inFirstQuadrant = (x >0 && y > 0)
}
```

Characteristics of the data classes:

- Implementation of `toString`, `equal` and `copy` regarding the fields declared in the primary constructor;

- Must have a primary constructor whose all parameters are marked with `val` or `var`;

- Cannot be `abstract`, `open`, or `inner`.

#### Operator overloading

```kotlin
data class Coordinate(var x: Int, var y: Int) {
    operator fun plusAssign(another: Coordinate) {
        x += another.x
        y += another.y
    }	
}

val coo = Coordinate(1, 2)
coo += Coordinate(2, 3)
```

### 12 Generics

```kotlin
open class Book(val name: String)

class Novel(name: String): Book(name)

class Textbook(name: String): Book(name)

class Bookshelf<T: Book>(vararg val books: T)

val shelf1 = Bookshelf(Novel("A song of Ice & Fire"), Novel("The load of the rings"))
val shelf2 = Bookshelf(Novel("A song of Ice & Fire"), Textbook("Introduction to Algorithms"))

fun <T: CharSequence> count(cs: T, startIdx: Int, char: Char) =
    cs.substring(startIdx).count {
        it == char
    }

```

```kotlin
val list1: List<Book> = listOf<Novel>(Novel("A"), Novel("B"))
val list2: MutableList<Book> = mutableListOf<Novel>(Novel("A"), Novel("B")) // wrong
```

Actually the `List` interface is like this:

```kotlin
public interface List<out E> : Collection<E> {
    ...
}
```

Here `out` means: any fields of a List whih the generic type `E` must be `val`. Thus `E` is a type only for readable fields.

On the other hand, there is `in`, which means a generic type is only for writable variables:

```kotlin
class A<in T> { // no fields of type T can be available to outside
    private var item: T? = null

    fun setItem(newItem: T) {
        item = newItem
    }
}

val a: A<Novel> = A<Book>()
```

The wildcard in Java generics has some similarities with the `in` and `out` in Kotlin, but they are not equivalent concepts.

### 13. Extensions

Based on anonymous function and generics, Kotlin brings the extensions, which enable us to extend classes with new functions and fields without inheritance. The Kotlin standard library contains a large numbers of extensions.

The code below

```kotlin
fun count(str: String, startIdx: Int, predicate: (Char) -> Boolean) =
    str.substring(startIdx).count(predicate)
    
count("Mississippi", 5) {
    it == 's'
}
```

could be refactored as

```kotlin
// just like we have extended the String class, a final class.
fun String.count(startIdx: Int, predicate: (Char) -> Boolean) =
    substring(startIdx).count(predicate)

"Mississippi".count(5) {
    it == 's'
}
```

Extend with fields is also available:

```kotlin
val String.countS
    get() = count { it == 's' || it == 'S' }

println("Mississippi".countS) // would print 4
```

Like computed properties, extended fields have no backing fields, actually the extended fields has no essential differences with extended methods.

Visibility modifiers are also valid for the extensions.

Extensions on nullable types:

```kotlin
// for such extension, the this is nullable
fun String?.printWithDefault(default: String) = println(this ?: default)

val s: String? = null
s.printWithDefault("what?") // no need to write s?. even when s is null.
```

Generics in extensions:

```kotlin
fun <T> T.prt() {
    println(this)
}

(1 + 1).prt()
```

Extensions in Kotlin standard library:

```kotlin
/**
 * Calls the specified function [block] with `this` value as its argument and returns its result.
 *
 * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).
 */
@kotlin.internal.InlineOnly
public inline fun <T, R> T.let(block: (T) -> R): R {
    contract {
        callsInPlace(block, InvocationKind.EXACTLY_ONCE)
    }
    return block(this)
}
```

Usage of the `let`:

```kotlin
class Y(val pair: Pair<String, String>?)

val y = Y(Pair("hello", "world"))
y.pair?.let {
    println(it.first + " " + it.second)
}

val p = y.pair
if (p != null) {
    println(p.first + " " + p.second)
}
```

Extension function type:

```kotlin
val greetings: String.() -> Unit = {
    println("Hello " + this.capitalize())
}

"Mississippi".greetings()
```

Another extension in Kotlin standard library:

```kotlin
/**
 * Calls the specified function [block] with `this` value as its receiver and returns its result.
 *
 * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).
 */
@kotlin.internal.InlineOnly
public inline fun <T, R> T.run(block: T.() -> R): R {
    contract {
        callsInPlace(block, InvocationKind.EXACTLY_ONCE)
    }
    return block()
}

File("x.txt").run {
    setReadable(true)
    setWritable(true)
    setExecutable(false)
}
```

### 14. Java Interoperability

#### Nullity

```kotlin
// in java side, mark non-private fields, return type and parameter type
// with annotations, thus helps Kotlin side handle nullity
class JavaClass {
    @NotNull
    public String x = "x";
    
    @Nullable
    public String f(@NotNull String y) {
        return null;
    }
}
```

Jetbrains created their annotations like this:
![](http://tao93.top/images/2019/11/05/1572992024.png)

While the annotations by Google is like this:
![](http://tao93.top/images/2019/11/05/1572992106.png)

### File level Kotlin members

Let's say we have a kotlin file Hello.kt which is:

```kotlin
// in Hello.kt file
// by default, the Hello.kt would generate a JVM class as HelloKt, 
// but we can change it like the following line.
@file:JvmName("Hello")

// file level members would be static members in generated JVM class
fun f() = "hello from kotlin."
```

### Kotlin functions with default parameter values

```kotlin
// add this annotation to make it generates several overloaded JVM methods
@JvmOverloads
fun f(name: String = "Unknown", age: Int = 0) {

}
```

#### Access members of companion object in Java

```kotlin
class H {
    companion object {
        @JvmField  // with this, H.x is valid in Java, or it would be H.companion.x
        val x = 10

        @JvmStatic  // with this, H.f is valid in Java
        fun f(){ }
    }
}
```

#### Exceptions

As we said earlier, Kotlin doesn't require we to try-catch code blocks which may throw checked Java Exceptions or add a `throws` declaration in the method signatures. So if a Java method is called with `throws` declaration is called in kotlin, we might missed the exceptions warning by the Java method.

For Kotlin methods which would be called by Java and might throw checked exceptions, marked it with annotation:

```kotlin
@Throws(IOException::class)
fun f() {
    throw FileNotFoundException()
}
```

#### Referred functions of Kotlin

```kotlin
// in Test.kt file
val translator = { utterance: String ->
    println(utterance.toLowerCase().capitalize())
}
```

```java
public class JavaClass {
	public static void main(String[] args) {
        Function1<String, Unit> translator = RoomKt.getTranslator();
        translator.invoke("MONey");
    }
}
```

What's the `Function1`:

```kotlin
/** A function that takes 1 argument. */
public interface Function1<in P1, out R> : Function<R> {
    /** Invokes the function with the specified argument. */
    public operator fun invoke(p1: P1): R
}
```

### Corutines


