---
title: Kotlin Summary
tags: [Kotlin]
---


### Table of Contents

1. [Before all](#before-all)
2. [Types](#types)
3. [Conditionals](#conditionals)
4. [Functions](#functions)
5. [Anonymous functions](#anonymous-functions)
6. [Null Safety and Exceptions](#null-safety-and-exceptions)
7. [Collections](#collections)
8. [Class definition](#class-definition)
9. [Object initialization](#object-initialization)
10. [Inheritance](#inheritance)
11. [Objects](#objects)
12. [Generics](#generics)
13. [Extensions](#extensions)
14. [Java Interoperability](#java-interoperability)
15. [Corutines](#coroutines)
16. [Functional Programming Basics](#functional-programming-basics)
17. [References](#references)


### 1. Before all <a name="before-all"/></a>

#### What's Kotlin

1. By Jetbrains which created Intellij IDEA
2. Targeting JVM and more, interoperatable with Java
3. Concise and safe, with many modern features

#### the REPL(read, evaluate, print, loop)

Install Kotlin commandline tools in macOS:

```bash
brew install kotlin
```

Execute `kotlinc` to start REPL

![](http://tao93.top/images/2019/11/05/1572994981.png)

### 2. Types <a name="types"/></a>

#### Built-in types

`String, Char, Boolean, Int, Double, List<T>, Set<T>, Map<K, V>, Array<T>`

Not like Java, Kotlin has no primitives (int, float etc.) hence avoids the boxing between primitives and objects. 

However, in byte code generated by Kotlin, primitives are used to improve performance.

### 3. Conditionals <a name="conditionals"/></a>

#### Conditional operators

Operator | Description
:-: | :-:
< | Evaluates whether the value on the left is less than the value on the right.
<= | Evaluates whether the value on the left is less than or equal to the value on the right.
> | Evaluates whether the value on the left is greater than the value on the right.
>= | Evaluates whether the value on the left is greater than or equal to the value on the right.
== | Evaluates whether the value on the left is equal to the value on the right (like equals in Java).
!= | Evaluates whether the value on the left is not equal to the value on the right.
=== | Evaluates whether the two instances point to the same reference (like == in Java).
!== | Evaluates whether the two instances do not point to the same reference.

### 4. Functions <a name="functions"/></a>

#### Kotlin supports file level functions

```kotlin
fun main() {
    println(fileLevelFunc())
}

fun fileLevelFunc() = "file level" // expression function
```

#### Default value of parameters

```kotlin
fun main() {
    greeting("Earth") // default value for 2nd parameter
}

fun greeting(name: String, greeting: String = "good morning") {
    println("${greeting.capitalize()}! $name.") // e.g. Good morning! Saturn.
}
```

#### Named function parameters

```kotlin
fun main() {
    greeting(greeting = "Hello", name = "Earth") // named parameters
}

fun greeting(name: String, greeting: String = "good morning") {
    println("${greeting.capitalize()}! $name.") // e.g. Good morning! Saturn.
}
```

#### Function names in backticks

It's said this is useful to call Java methods whose names are reserved words in Kotlin, or to name some special methods.

```kotlin
fun `ðŸ˜‚`() { }

fun main() {
    `ðŸ˜‚`() // call a function
}
```

#### Inline functions

Kotlin support inline functions, which is good for performance.

```kotlin
inline fun factorial(n: Int): Int {
    return if (n > 2) {
        n * factorial(n - 1)  // wrong, no recursion inside inline functions
    } else {
        n
    }
}
```

### 5. Anonymous functions <a name="anonymous-functions"/></a>

The complete structure of an anoymous function should be like:

```kotlin
val funcVariable: (ParamType1, ParamType2) -> ReturnType = 
{ param1: ParamType1, param2: ParamType2 ->
	...
	expr_to_be_returned // no return keyword, only the returned expression
}
```

An example of anoymous function:

```kotlin
val numLetters = "Mississippi".count({ letter ->
    letter == 's'
})
print(numLetters) // would Prints 4
```

```kotlin
/**
 * Returns the number of characters matching the given [predicate].
 */
public inline fun CharSequence.count(predicate: (Char) -> Boolean): Int {
    var count = 0
    for (element in this) if (predicate(element)) ++count
    return count
}
```

Parameter types are usually omitted when they caould be inferred. Single parameter's name could be omitted if its type could ba inferred, and we take `it` as the parameter name. Unused parameter name could be marked as **`_`**.

Examples:

```kotlin
val numLetters = "Mississippi".count({
    it == 's'
})

val afterFilter = "Mississippi".filterIndexed({ _, char->
    char != 's'
})
print(afterFilter) // prints Miiippi
```

***Note***: an anonymous function must be called immediately, assigned to a variable, or be passed as a parameter.

Anonymous functions as parameter is often in a different style when it is required as the **last** parameter in another function:

```kotlin
// count starting from a specified index.
fun count(str: String, startIdx: Int, predicate: (Char) -> Boolean): Int {
    return str.substring(startIdx).count(predicate)
}

// style 1
count("Mississippi", 5, {
    it == 's'
})

// style 2, looks like definition of count, 
// but actually it's anonymous function as parameter
count("Mississippi", 5) {
    it == 's'
}
```

Want to declare a function type that returns something like `void` in Java? You need the `Unit`.

You can also refer a non anonymous function as parameter in call to another function by using `::`. But I don't think this is common.

```kotlin
fun isS(char: Char): Boolean {
    return char == 's'
}
    
val numLetters = "Mississippi".count(::isS)
```

### 6. Null Safety and Exceptions <a name="null-safety-and-exceptions"/></a>

For nullable variables, there are some common solutions to handle potential null pointer exceptions.

**Safe call operator**:

```kotlin
var beverage = readLine()?.capitalize() // the beverage would be String?.
```

**Nonnull assertion**:

```kotlin
var beverage = readLine()!!.capitalize() // only if you're really confident
```

**Check before use**:

```kotlin
val result = readLine()
var beverage = if (result != null) { // type of beverage would be String.
    result.capitalize() + result.toLowerCase()
} else {
    ""
}
```

However, check before use isn't always safe, e.g. a field of an object might be assigned null by another thread between your null checking and usage of the field. For such case, you would need a local variable to get rid of this risk:

```kotlin
val localVar = a.b
if (localVar != null) {
    // do something refers localVar
} else {
    ...
}
```

**Elvis operator**:

```kotlin
var beverage = readLine()?.capitalize() ?: ""  // beverage would be String.
```

#### Exceptions in Kotlin

Kotlin doesn't require handling of those checked Exceptions of Java. Therefore you can do IO operations without try-catch and exception declaration in the method signature.

### 7. Collections <a name="collections"/></a>

#### destructuring

```kotlin
val (type, name, price) = aList  // fetch the leading 3 elements from a list.

val (type, _, price) = aList // skip elements in specified indexes.
```

#### protection of immutable list is not valid at runtime

```kotlin
val a = listOf(1, 2, 3)
(a as MutableList<Int>).set(0, 100)
println(a) // would print [100, 2, 3]
```

### 8. Class definition <a name="class-definition"/></a>

#### Visibility modifiers of class members

Modifier | Description
:-: | :-:
public (default) |	The function or property will be accessible by code outside of the class. By default, functions and properties without a visibility modifier are public.
private | The function or property will be accessible only within the same class.
protected | The function or property will be accessible only within the same class or its subclass.
internal | The function or property will be accessible within the same module.

#### Class fields

For class fields, default `getter` is available for `val` and `var` fields. But `setter` is only for `var` fields. Yet we can override the default `setter` and `getter`:

```kotlin
class X(_name: String, _age: Int) {
    
    // a field always return capitalized string when you get it
    val name = _name
        get() = field.capitalize()
    
    // a field only allows increasing
    var age = _age
        set(value) {
            if (value > field) {
                field = value
            }
        }
}
```

You can override the visibility of a setter to make it less permissive then field's visibility. E.g., you want to make a field readable everywhere but only writable in the file:

```kotlin
class X(_age: Int) {
    // a field only allows increasing in current file.
    var age = _age
        private set(value) {
            if (value > field) {
                field = value
            }
        }
}
```

#### Computed fields

Has getter or/and setter but no real fields to store values.

```kotlin
class Dice() {
    val rolledValue
        get() = (1..6).shuffled().first()
}
```

### 9. Object initialization <a name="object-initialization"/></a>

#### The primary contructor

Add parameter list inside a pair of parenthesis after the class name, make it looks like a method. For fields **using default getter and setter**, you can declare them inside the parameter list by adding `var` or `val`:

```kotlin
// visibility modifier and default values are also available
class X(val name: String, private var age: Int = 0)
```

#### secondary constructor

Must call the primary constructor or another secondary constructor(of course no cycle call)

```kotlin
class X(val name: String, private var age: Int = 0) {
    // call primary constructor with default parameter
    constructor(): this("Unknown")
}
```

Apart from default parameter values, named parameters are also available for constructors.

#### Lazy initialization

Only initialize a field when it's accessed (by the getter)

```kotlin
class X {
    val number: Int by lazy {
        (0 until 10).shuffled().first() // not good example
    }
}
```

### 10. Inheritance <a name="inheritance"/></a>

In Java, we only override methods. But in Kotlin, both class functions and fields could be overridden. Also, in Kotlin, classes, functions and fields must be marked `open` explicity to make them inheritable or able to be overridden. 

```kotlin
open class Room(val name: String) {
    protected open val dangerLevel = 5

    fun description() = "Room: $name\n" +
            "Danger level: $dangerLevel"

    open fun load() = "Nothing much to see here..."
}

class TownSquare : Room("Town Square") {
    override val dangerLevel = super.dangerLevel - 3

    final override fun load() = "The villagers cheer as you enter!"
}
```

Functions are final by default unless they are inherited from an open class. To prevent inherited functions from being overriden again, we can mark it `final`.

In Kotlin's inheritance, we always have:

![](http://tao93.top/images/2019/11/05/1572968935.png)

However, when compiled into bytecode, the class Room doesn't inherits the class Any in JVM rule.

### 11. Objects <a name="objects"/></a>

#### singleton by `object` keyword

```kotlin
fun main() {
    UserManager.getUser(2)
}

// constructors are not allowed for such objects
object UserManager {
    private val users = mutableListOf<String>("A", "B")
    
    fun getUser(idx: Int): String? {
        return users.getOrNull(idx)
    }
}
```

#### Anonymous inner class 

In java, we often implement interfaces or extend simple classes as anonymous inner class, such as click listeners and view adapters.

In Kotlin, they could be divided into 2 categories. For interfaces with only one method and declared in Java, we can use a format called Lambda:

```kotlin
generateButton.setOnClickListener { view ->
    fetchData()
}

fun useI(i: I) {

}

useI(I {
    // ...
})
```

```java
// I.java
public interface I {
    void f();
}
```

For other cases, the format is like this:

```kotlin
listView.adapter = object : BaseAdapter() {  // call the constructor here.
    override fun getView(pos: Int, view: View?, parent: ViewGroup?): View {
        // ...
    }

    override fun getItem(pos: Int): Any {
        // ...
    }

    override fun getItemId(pos: Int): Long {
        // ...
    }

    override fun getCount(): Int {
        // ...
    }
}
```

Nested classes by default cannot access members of the outer class, unless they are marked inner:

```kotlin
class Outer {
    fun outerFunc() = "1"

    class Nested {
        init {
            outerFunc()  // wrong, unable to access
        }
    }

    inner class Inner {
        init {
            outerFunc()  // ok
        }
    }
}

object UserManager {
    private val users = mutableListOf<String>("A", "B")

    class User {
        init {
            users // ok. this is nested class inside an object class.
        }
    }
}
```

#### Data classes

Data classes are suitable for model, that's what the `data` means.

```kotlin
data class Coordinate(var x: Int, var y: Int) {
    val inFirstQuadrant = (x >0 && y > 0)
}
```

when use the data classes:

- Implementation of `toString`, `equal` and `copy` regarding the fields declared in the primary constructor;

- Must have a primary constructor whose all parameters are marked with `val` or `var`;

- Cannot be `abstract`, `open`, or `inner`.

#### Operator overloading

```kotlin
data class Coordinate(var x: Int, var y: Int) {
    operator fun plusAssign(another: Coordinate) {
        x += another.x
        y += another.y
    }	
}

val coo = Coordinate(1, 2)
coo += Coordinate(2, 3)
```

```kotlin
object Fact {
    operator fun invoke(n: Int): Int {
        return if (n > 2)
            n * this(n-1)
        else
            n
    }
}

println(Fact(5))
```

### 12 Generics <a name="generics"/></a>

```kotlin
open class Book(val name: String)

class Novel(name: String): Book(name)

class Textbook(name: String): Book(name)

class Bookshelf<T: Book>(vararg val books: T)

val shelf1 = Bookshelf(Novel("A song of Ice & Fire"), 
                       Novel("The load of the rings"))
val shelf2 = Bookshelf(Novel("A song of Ice & Fire"), 
                       Textbook("Introduction to Algorithms"))

fun <T: CharSequence> count(cs: T, startIdx: Int, char: Char) =
    cs.substring(startIdx).count {
        it == char
    }

```

```kotlin
val list1: List<Book> = listOf<Novel>(Novel("A"), Novel("B"))
// the following line is wrong!
val list2: MutableList<Book> = mutableListOf<Novel>(Novel("A"), Novel("B"))
```

Actually the `List` interface is like this:

```kotlin
public interface List<out E> : Collection<E> {
    ...
}
```

Here `out` means: any fields of a List whih the generic type `E` must be `val`. Thus `E` is a type only for readable fields.

On the other hand, there is `in`, which means a generic type is only for writable variables:

```kotlin
class A<in T> { // no fields of type T can be available to outside
    private var item: T? = null

    fun setItem(newItem: T) {
        item = newItem
    }
}

val a: A<Novel> = A<Book>()
```

The wildcard in Java generics has some similarities with the `in` and `out` in Kotlin, but they are not equivalent concepts.

### 13. Extensions <a name="extensions"/></a>

Based on anonymous function and generics, Kotlin brings the extensions, which enable us to extend classes with new functions and fields without inheritance. The Kotlin standard library contains a large numbers of extensions.

The code below

```kotlin
fun count(str: String, startIdx: Int, predicate: (Char) -> Boolean) =
    str.substring(startIdx).count(predicate)
    
count("Mississippi", 5) {
    it == 's'
}
```

could be refactored as

```kotlin
// just like we have extended the String class, a final class.
fun String.count(startIdx: Int, predicate: (Char) -> Boolean) =
    substring(startIdx).count(predicate)

"Mississippi".count(5) {
    it == 's'
}
```

Extend with fields is also available:

```kotlin
val String.countS
    get() = count { it == 's' || it == 'S' }

println("Mississippi".countS) // would print 4
```

Like computed properties, extended fields have no backing fields, actually the extended fields has no essential differences with extended methods.

Visibility modifiers are also valid for the extensions.

Extensions on nullable types:

```kotlin
fun <T> T?.chkNull(block1: (T) -> Unit, block2: () -> Unit) {
    if (this != null) { // for such extension, the this is nullable
        block1(this)
    } else {
        block2()
    }
}

class C(val x: String? = listOf<String?>("s", null).shuffled().first())

val c = C()
c.x.chkNull({   // no need to write c.x?. even that c.x is nullable.
    // it ...
}, {

})
```

Generics in extensions:

```kotlin
fun <T> T.prt() {
    println(this)
}

(1 + 1).prt()
```

Extensions in Kotlin standard library:

```kotlin
/**
 * Calls the specified function [block] with `this` value as its argument 
 * and returns its result.
 *
 * For detailed usage information see the documentation for [scope functions]
 * (https://kotlinlang.org/docs/reference/scope-functions.html#let).
 */
@kotlin.internal.InlineOnly
public inline fun <T, R> T.let(block: (T) -> R): R {
    contract {
        callsInPlace(block, InvocationKind.EXACTLY_ONCE)
    }
    return block(this)
}
```

Usage of the `let`:

```kotlin
class Y(val pair: Pair<String, String>?)

val y = Y(Pair("hello", "world"))

y.pair?.let {
    println(it.first + " " + it.second)
}

val p = y.pair
if (p != null) {
    println(p.first + " " + p.second)
}
```

Extension function type:

```kotlin
val greetings: String.() -> Unit = {
    println("Hello " + this.capitalize())
}

"Mississippi".greetings()
```

Another extension in Kotlin standard library:

```kotlin
/**
 * Calls the specified function [block] with `this` value as its receiver 
 * and returns its result.
 *
 * For detailed usage information see the documentation for [scope functions]
 * (https://kotlinlang.org/docs/reference/scope-functions.html#run).
 */
@kotlin.internal.InlineOnly
public inline fun <T, R> T.run(block: T.() -> R): R {
    contract {
        callsInPlace(block, InvocationKind.EXACTLY_ONCE)
    }
    return block()
}

File("x.txt").run {
    setReadable(true)
    setWritable(true)
    setExecutable(false)
}
```

### 14. Java Interoperability <a name="java-interoperability"/></a>

#### Nullity

```kotlin
// in java side, mark non-private fields, return type and parameter type
// with annotations, thus helps Kotlin side handle nullity
class JavaClass {
    @NotNull
    public String x = "x";
    
    @Nullable
    public String f(@NotNull String y) {
        return null;
    }
}
```

Jetbrains created their annotations like this:
![](http://tao93.top/images/2019/11/05/1572992024.png)

While the annotations by Google is like this:
![](http://tao93.top/images/2019/11/05/1572992106.png)

### File level Kotlin members

Let's say we have a kotlin file Hello.kt which is:

```kotlin
// in Hello.kt file
// by default, the Hello.kt would generate a JVM class as HelloKt, 
// but we can change it like the following line.
@file:JvmName("Hello")

// file level members would be static members in generated JVM class
fun f() = "hello from kotlin."
```

### Kotlin functions with default parameter values

```kotlin
// add this annotation to make it generates several overloaded JVM methods
@JvmOverloads
fun f(name: String = "Unknown", age: Int = 0) {

}
```

#### Access members of companion object in Java

```kotlin
class H {
    companion object {
        @JvmField  // then H.x is ok in Java, or we need H.companion.x
        val x = 10

        @JvmStatic  // then H.f is ok in Java
        fun f(){ }
    }
}
```

#### Exceptions

As we said earlier, Kotlin doesn't require we to try-catch code blocks which may throw checked Java Exceptions or add a `throws` declaration in the method signatures. So if a Java method is called with `throws` declaration is called in kotlin, we might missed the exceptions warning by the Java method.

For Kotlin methods which would be called by Java and might throw checked exceptions, marked it with annotation:

```kotlin
@Throws(IOException::class)
fun f() {
    throw FileNotFoundException()
}
```

#### Referred functions of Kotlin

```kotlin
// in Test.kt file
val translator = { utterance: String ->
    println(utterance.toLowerCase().capitalize())
}
```

```java
public class JavaClass {
	public static void main(String[] args) {
        Function1<String, Unit> translator = RoomKt.getTranslator();
        translator.invoke("MONey");
    }
}
```

What's the `Function1`:

```kotlin
/** A function that takes 1 argument. */
public interface Function1<in P1, out R> : Function<R> {
    /** Invokes the function with the specified argument. */
    public operator fun invoke(p1: P1): R
}
```

### 15. Corutines <a name="coroutines"/></a>

#### what are coroutines

- coroutines are more lightweight than threads

- a thread can schedule between multiple coroutines

- a coroutine can switch between threads

### `async` & `launch`

the most common ways to create coroutines

```kotlin
public fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -> Unit
): Job

public interface Job : CoroutineContext.Element {
    public suspend fun join()
    ...
}
```

```kotlin
public fun <T> CoroutineScope.async(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -> T
): Deferred<T>

public interface Deferred<out T> : Job {
    public suspend fun await(): T
    ...
}
```

`Deferred<T>` is also a `job`, only that we can call its `await` to fetch an result returned by that coroutine. e.g:

```kotlin
private fun fetchData() {
    GlobalScope.launch(Dispatchers.Main) { 
        // type of result: Deferred<CharacterData>
        val result = GlobalScope.async(Dispatchers.Default) {
            val (race, name, dex, wis, str) = URL(
            "https://chargen-api.herokuapp.com/").readText().split(",")
            CharacterData(race, name, dex, wis, str)
        }
        characterData = result.await()
        displayCharacterData() // use the fetched characterData
    }
}

private fun displayCharacterData() {
    characterData.run {
        nameTextView.text = name
        raceTextView.text = race
        dexterityTextView.text = dex
        wisdomTextView.text = wis
        strengthTextView.text = str
    }
}
```

### `suspend` functions

In my oppnion, a function with `suspend` means 3 things:

1. it might takes a not short period of time to finish it (but not blocking a thread);
2. if declared in `kotlinx.coroutines`, then it's a cancelable point;
3. might be a schedule point for threads.

The most common `suspend` method, `delay`, fulfills the 3 conclusions, so does the `Deferred.await` method.

### the cancelable point

Able to cancel:

```kotlin
fun main() = runBlocking {
    val job = launch {
        delay(3000)
        println("You won't see me since I would be canceled.")
    }
    delay(100)
    job.cancel()
}
```

Unable to cancel:

```kotlin
fun main() = runBlocking {
    val job = launch {
        compute()
        println("No way to cancel me!")
    }
    delay(100)
    job.cancel()
}

fun compute() {
    val startTime = System.currentTimeMillis()
    var lastTime = startTime
    while (lastTime - startTime < 3_000) {
        if (System.currentTimeMillis() - lastTime >= 1000) {
            lastTime += 1000
            println((lastTime - startTime) / 1000)
        }
    }
}
```

**Note**: `runBlocking` would be explained later.

### Coroutine context

```kotlin
fun main() = runBlocking<Unit> {
    launch(Dispatchers.Default + CoroutineName("test")) {
        println("I'm working in thread ${Thread.currentThread().name}")
    }
}
```

### Coroutine scope

`scope` is just like variables have scope in most programming languages

```kotlin
fun func() {
    if (1 + 1 == 2) {
        val x = 3 // x belongs to the if scope
    }
}
```

the `CoroutineScope` interface

```kotlin
public interface CoroutineScope {
    public val coroutineContext: CoroutineContext
}
```

In kotlin, `CoroutineScope` is implemented by `AbstractCoroutine`, hence a coroutine means a `CoroutineScope`, but not vice versa.

Parent coroutine and child coroutine:

```kotlin
GlobalScope.launch { 
    // only inside a coroutine can we call launch & async directly.
    launch { 
        
    }
}
```

Direct calls of `launch` & `async` also means children coroutines inherits `Dispatchers` from parent unless override by providing a `Dispatchers` parameter. 

```kotlin
GlobalScope.launch(Dispatchers.Main) { 
    // only inside a coroutine can we call launch & async directly.
    launch(Dispatchers.Default) { 
        
    }
}
```

Normally, parent finish after all children finish. But there is a extension method of `CoroutineScope ` naming `cancel`. When it's called, the whole coroutine tree are canceled.

```kotlin
/**
 * Cancels this scope, including its job and all its children with an 
 * optional cancellation [cause].
 * A cause can be used to specify an error message or to provide other 
 * details on a cancellation reason for debugging purposes.
 * Throws [IllegalStateException] if the scope does not have a job in it.
 */
public fun CoroutineScope.cancel(cause: CancellationException? = null)
```

In kotlin, we have a `GlobalScope` which is an `object` singleton. Coroutines directly created from `GlobalScope` can last long as long as the JVM is on. `GlobalScope` is convenient for demo, however we may want coroutines to be canceled when an `Activity` is destroyed, for example.

```kotlin
class MyActivity : AppCompatActivity() {
    private val mainScope = MainScope()

    override fun onDestroy() {
        super.onDestroy()
        mainScope.cancel()
    }
    
    mainScope.launch(Dispatchers.Main) { 
        // type of result: Deferred<CharacterData>
        val result = mainScope.async(Dispatchers.Default) {
            val (race, name, dex, wis, str) = URL(
            "https://chargen-api.herokuapp.com/").readText().split(",")
            CharacterData(race, name, dex, wis, str)
        }
        characterData = result.await()
        displayCharacterData() // use the fetched characterData
    }
}
```

Now let's go back to explain `runBlocking`. `runBlocking` also starts a coroutine from `GlobeSope`, only that `runBlocking` coroutines prevent JVM from ending.

#### the `coroutineScope(block)` method

```kotlin
suspend fun <R> coroutineScope(block: suspend CoroutineScope.() -> R): R
```

We can create a new scope with this `coroutineScope` method. The most common usage would be like this:

```kotlin
suspend fun doSomeThing(): Int = coroutineScope {
    val deferred = async(Dispatchers.IO) { 
        delay(500)
        3
    }
    deferred.await()
}

GlobalScope.launch(Dispatchers.Main) { 
    val result = doSomeThing()
    // use the result
}
```
In the above code, we created a scope with `coroutineScope`. When `doSomeThing` is called from another coroutine, the scope we created would inherit context from the outer coroutine scope. More importantly, when the outer scope is cancelled, this scope would also be canceled.

In next section, we would see the `coroutineScope` has important role in exception handling.

### Exception in coroutines

First, what is a crash in Android app? (excluding ANR).

The simplest and best way to handle exceptions, is catching exceptions locally, i.e. don't let exceptions be passed between coroutines. Like the following:

```kotlin
suspend fun doSomeThing(): Int = coroutineScope {
    val deferred: Deferred<Int> = async(Dispatchers.IO) {
        try {
            // ... the regular code block.
            3 // assume 3 is a valid return
        } catch (e: IndexOutOfBoundsException) {
            // do something to handle
            0 // assume 0 is a default return
        }
    }
    deferred.await()
}
```

It's simple, but why best? Because when an exception is not caught inside a coroutine, the exception would mostly cancel the whole coroutine tree. 

```kotlin
fun main() {
    // all coroutines would be canceled, and the thread would crash
    GlobalScope.launch {
        launch {
            delay(200)
            println("You won't see me since I would be canceled.")
        }
        launch {
            throw IndexOutOfBoundsException()
        }

        delay(200)
        println("You won't see me since I would be canceled.")
    }

    runBlocking { delay(500) }
}
```

However, with the `coroutineScope` method, we can do more.

```kotlin
suspend fun doSomeThing(): Int = coroutineScope {
    val deferred: Deferred<Int> = async(Dispatchers.IO) {
        throw IndexOutOfBoundsException()
    }
    launch { // this would be canceled
        delay(200)
        println("You won't see me since I would be canceled.")
    }
    deferred.await()
}

fun main() {
    GlobalScope.launch {
        launch {
            delay(200)
            println("I wouldn't be canceled.")
        }
        launch {
            try { doSomeThing() } // doSomeThing throws the exception
            catch (e: IndexOutOfBoundsException) {
                println("caught the exception: $e")
            }
        }

        delay(200)
        println("I wouldn't be canceled, either.")
    }

    runBlocking { delay(500) }
}
```

### the `CancellationException`

It is thrown when a coroutine is canceled, but won't crash the JVM thread.

just like nothing happen:

```kotlin
fun main() {
    // just like nothing happen
    GlobalScope.launch {
        throw CancellationException()
    }
    runBlocking { delay(500) }
}
```

JVM thread would crash:

```kotlin
fun main() {
    GlobalScope.launch {
        throw IndexOutOfBoundsException()
    }
    runBlocking { delay(500) }
}
```

`CancellationException` seems useless, but it can be caught if you want. Just surround the cancel point inside a coroutine with try-catch.

```kotlin
fun main() {
    // just like nothing happen
    GlobalScope.launch {
        launch {
            delay(100)
            throw IndexOutOfBoundsException()
        }
        try { delay(50) } catch (e: CancellationException) {
            println("caught 1: $e")
            throw e // usually you should throw it again
        }
        try { delay(60) } catch (e: CancellationException) {
            println("caught 2: $e")
            throw e // usually you should throw it again
        }
        // ...
    }
    runBlocking { delay(500) }
}
```

Look the the code above, if you don't throw again the `CancellationException` again, the coroutine would continue executing, which usually is abnormal.

### the `CoroutineExceptionHandler`

We can set an `CoroutineExceptionHandler` to the root scope or the root coroutine to let the handler handle exceptions throws inside all coroutines.

```kotlin
fun main() {
    val ceh = CoroutineExceptionHandler { _, e ->
        println("Handled crash: $e")
    }

    //CoroutineScope(Dispatchers.IO).launch(ceh) {  // this also works
    CoroutineScope(Dispatchers.IO + ceh).launch {
        launch(Dispatchers.Default) {
            throw IndexOutOfBoundsException()
        }
    }

    runBlocking { delay(500) }
}
```

```kotlin
// would crash!!
fun main() {
    val ceh = CoroutineExceptionHandler { _, e ->
        println("Handled crash: $e")
    }

    CoroutineScope(Dispatchers.IO).launch {
        launch(Dispatchers.Default + ceh) {
            throw IndexOutOfBoundsException()
        }
    }

    runBlocking { delay(500) }
}
```

If a coroutine is created from `async`, the `await` function would also throw the exception escaped from the coroutine:

```kotlin
fun main() {
    val ceh = CoroutineExceptionHandler { _, e ->
        println("Handled crash: $e")
    }

    CoroutineScope(Dispatchers.IO).launch(ceh) {
        val d: Deferred<Int> = async() { oops(); 3 }

        try {
            println(d.await())
        } catch (e: IndexOutOfBoundsException) {
            println("caught: $e")
        }
    }

    runBlocking { delay(500) }
}

fun oops() {
    throw IndexOutOfBoundsException()
}
```

### 16. Functional Programming Basics <a name="functional-programming-basics"/></a>

### Transforms

A transform function works on the contents of a collection by walking through the collection and transforming each item with a transformer function provided as an argument.

the `map` method

```kotlin
/**
 * Returns a list containing the results of applying the given [transform] 
 * function to each element in the original collection.
 * 
 * @sample samples.collections.Collections.Transformations.map
 */
public inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {
    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)
}
```

### Filters

A filter function accepts a predicate function that checks each element in a collection against a condition and returns either true or false.

the `filter` method

```kotlin
/**
 * Returns a list containing only elements matching the given [predicate].
 */
public inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {
    return filterTo(ArrayList<T>(), predicate)
}
```

### Combines

Combining functions take different collections and merge them into a new one.

the `zip` method

```kotlin
/**
 * Returns a sequence of values built from the elements of `this` sequence 
 * and the [other] sequence with the same index.
 * The resulting sequence ends as soon as the shortest input sequence ends.
 *
 * The operation is _intermediate_ and _stateless_.
 * 
 * @sample samples.collections.Sequences.Transformations.zip
 */
public infix fun <T, R> Sequence<T>.zip(other: Sequence<R>): 
Sequence<Pair<T, R>> {
    return MergingSequence(this, other) { t1, t2 -> t1 to t2 }
}
```

Examples

```kotlin
// get primes
(2..1000).filter { num->
    (2 until num).filter { 
        num % it == 0
    }.isEmpty()
}

// get primes with the none
val primes = (2..1000).filter { num->
    (2 until num).none {
        num % it == 0
    }
}
```

### References <a name="references"/></a>

1. [Kotlin Programming: The Big Nerd Ranch Guide](https://www.bignerdranch.com/books/kotlin-programming-the-big-nerd-ranch-guide-2/), awailable in the [O'Reilly Learning](https://learning.oreilly.com/home/) platform.
2. Official [Kotlin coroutine guide](https://kotlinlang.org/docs/reference/coroutines/coroutines-guide.html).
3. [Exceptional Exceptions for Coroutines made easyâ€¦?](https://medium.com/the-kotlin-chronicle/coroutine-exceptions-3378f51a7d33)
